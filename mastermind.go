// Copyright (c) 2018 codeliveroil. All rights reserved.
//
// This work is licensed under the terms of the MIT license.
// For a copy, see <https://opensource.org/licenses/MIT>.

package main

import (
	"errors"
	"fmt"
	"os"

	"github.com/codeliveroil/niceflags"
)

func main() {
	args := os.Args
	flags := niceflags.NewFlags(
		args[0],
		"Mastermind code breaking game",
		"In this game, the player tries to decode a secret code that is generated by the computer using 'n' colored pegs. "+
			"The player has 10 attempts to guess or decode the secret.\n\n"+
			"With each attempt, the computer will let the user know how good the attempt was:\n"+
			"- white dots indicate how many pegs in the attempt are of the right color and also in the right position.\n"+
			"- gray dots indicate how many pegs are of the right color but in the wrong position\n\n"+
			"For example, if the secret code is |red|green|yellow|blue| and the player's attempt is |pink|green|blue|yellow|, "+
			"then the result is going to be 1 white dot (because the green peg is the right color and in the right position)"+
			" and 2 gray dots (because the blue and yellow pegs are the right colors in play but are in the wrong positions). "+
			"The pink peg is not in the secret code so the player has to figure this out by noticing that the feedback has a "+
			"total of only 3 dots even though the size of the secret is 4.\n"+
			"\n"+
			"In-game keys:\n"+
			"  left-arrow/right-arrow : select peg\n"+
			"  enter                  : confirm peg\n"+
			"  backspace              : delete peg\n"+
			"  q                      : quit",
		"[options]",
		"help",
		false,
	)

	codeSize := flags.Int("s", 4, "Specify the `size` of the code (4 - 10).")
	uniquePegCount := flags.Int("p", 6, "Specify the `num`ber of uniquely colored pegs to use (1 - 8).")
	maxRepeats := flags.Int("r", 1, "Specify the `num`ber of times each peg can be repeated (1 - 10).")
	version := flags.Bool("v", false, "Display version.")

	check(flags.Parse(args[1:]))
	flags.Help()
	if *version {
		fmt.Println("1.0")
		os.Exit(0)
	}

	b, err := newBoard(*codeSize, *uniquePegCount, *maxRepeats)
	check(err)
	b.clear()
	b.draw()

outer:
	for {
		key, err := readKey()
		if err != nil {
			check(errors.New("could not read key: " + err.Error()))
		}
		switch key {
		case "left-arrow":
			b.selectPeg(false)
			b.draw()
		case "right-arrow":
			b.selectPeg(true)
			b.draw()
		case "enter":
			b.confirmPeg()
			b.draw()
			if b.won() || b.lost {
				break outer
			}
		case "backspace":
			b.deletePeg()
			b.draw()
		case "q":
			b.lost = true
			b.draw()
			break outer
		}
	}
	fmt.Println("")

	if b.won() {
		pr := float64(b.currRow) / maxTries
		if pr < 0.25 {
			fmt.Println("You nailed it!")
		} else if pr > 0.75 {
			fmt.Println("That was close!")
		} else {
			fmt.Println("Nice job!")
		}
	}

	if b.lost {
		fmt.Println("Better luck next time!")
	}

}

// check handles errors.
func check(err error) {
	if err != nil {
		niceflags.PrintErr("%v\n", err)
		os.Exit(1)
	}
}
