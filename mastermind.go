// Copyright (c) 2018 codeliveroil. All rights reserved.
//
// This work is licensed under the terms of the MIT license.
// For a copy, see <https://opensource.org/licenses/MIT>.

package main

import (
	"errors"
	"flag"
	"fmt"
	"os"
	"path"
)

func main() {
	args := os.Args
	flags := flag.NewFlagSet(os.Args[0], flag.ExitOnError)
	printToErr := func(msg string, args ...interface{}) {
		fmt.Fprintf(os.Stderr, msg, args...) //stderr because that's where 'flags.PrintDefaults()' prints to
	}

	fullUsage := func() {
		printToErr("Mastermind code breaking game                                                  \n")
		printToErr("  In this game, the player tries to decode a secret code that is generated by  \n")
		printToErr("  the computer using 'n' colored pegs. The player has 10 attempts to guess or  \n")
		printToErr("  decode the secret.                                                           \n")
		printToErr("                                                                               \n")
		printToErr("  With each attempt, the computer will let the user know how good the attempt  \n")
		printToErr("  was:                                                                         \n")
		printToErr("   - white dots indicate how many pegs in the attempt are of the right color   \n")
		printToErr("     and also in the right position.                                           \n")
		printToErr("   - gray dots indicate how many pegs are the right color but in the wrong     \n")
		printToErr("     position.                                                                 \n")
		printToErr("                                                                               \n")
		printToErr("  For example, if the secret code is |red|green|yellow|blue| and the player's  \n")
		printToErr("  attempt is |pink|green|blue|yellow|, then the result is going to be 1 white  \n")
		printToErr("  dot (because the green peg is the right color and in the right position) and \n")
		printToErr("  2 gray dots (because the blue and yellow pegs are the right colors in play   \n")
		printToErr("  but are in the wrong positions). The pink peg is not in the secret code so   \n")
		printToErr("  the player has to figure this out by noticing that the feedback has a total  \n")
		printToErr("  of only 3 dots even though the size of the secret is 4.                      \n")
		printToErr("                                                                               \n")
		printToErr("In-game keys:                                                                  \n")
		printToErr("  left-arrow/right-arrow : select peg                                          \n")
		printToErr("  enter                  : confirm peg                                         \n")
		printToErr("  backspace              : delete peg                                          \n")
		printToErr("  q                      : quit                                                \n")
		flags.Usage()
	}

	flags.Usage = func() {
		printToErr("\nUsage: %s [options]\n", path.Base(os.Args[0]))

		printToErr("\nOptions:\n")
		printFlag := func(f *flag.Flag) { //go's default 2 line display for non-bools is not appealing, use custom printer.
			printToErr("  -%v %v\n", f.Name, f.Usage)
		}
		flags.VisitAll(printFlag)
	}

	codeSize := flags.Int("s", 4, "num   "+"Specify the size of the code (4 - 10).")
	uniquePegCount := flags.Int("p", 6, "num   "+"Specify the number of uniquely colored pegs to use (1 - 8).")
	maxRepeats := flags.Int("r", 1, "num   "+"Specify how many times each peg can be repeated (1 - 10).")
	help := flags.Bool("h", false, "      "+"Display help screen.")
	version := flags.Bool("v", false, "      "+"Display version.")

	check(flags.Parse(args[1:]))
	if *help {
		fullUsage()
		os.Exit(0)
	}
	if *version {
		fmt.Println("1.0")
		os.Exit(0)
	}

	b, err := newBoard(*codeSize, *uniquePegCount, *maxRepeats)
	check(err)
	b.clear()
	b.draw()

outer:
	for {
		key, err := readKey()
		if err != nil {
			check(errors.New("could not read key: " + err.Error()))
		}
		switch key {
		case "left-arrow":
			b.selectPeg(false)
			b.draw()
		case "right-arrow":
			b.selectPeg(true)
			b.draw()
		case "enter":
			b.confirmPeg()
			b.draw()
			if b.won() || b.lost {
				break outer
			}
		case "backspace":
			b.deletePeg()
			b.draw()
		case "q":
			b.lost = true
			b.draw()
			break outer
		}
	}
	fmt.Println("")

	if b.won() {
		pr := float64(b.currRow) / maxTries
		if pr < 0.25 {
			fmt.Println("You nailed it!")
		} else if pr > 0.75 {
			fmt.Println("That was close!")
		} else {
			fmt.Println("Nice job!")
		}
	}

	if b.lost {
		fmt.Println("Better luck next time!")
	}

}

// check handles errors.
func check(err error) {
	if err != nil {
		fmt.Println(err)
		os.Exit(1)
	}
}
